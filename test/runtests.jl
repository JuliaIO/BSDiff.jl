using Test
using BSDiff
using Pkg.Artifacts

import bsdiff_jll

const test_data = artifact"test_data"

function zrle(data::String)
    sprint() do io
        io = BSDiff.ZrleIO(io)
        write(io, codeunits(data))
        flush(io)
    end
end

function zrld(data::String)
    read(BSDiff.ZrleIO(IOBuffer(data)), String)
end

function test_zrle(raw::String, enc::String)
    @test zrle(raw) == enc
    @test zrld(enc) == raw
end

@testset "ZRLE" begin
    test_zrle("", "")
    test_zrle("xyz", "xyz")
    test_zrle("\0", "\0\0")
    test_zrle("\0\0", "\0\1")
    test_zrle("\0\0\0", "\0\2")
    test_zrle("\0xyz", "\0\0xyz")
    test_zrle("\0\0xyz", "\0\1xyz")
    test_zrle("\0\0\0xyz", "\0\2xyz")
    test_zrle("xyz\0", "xyz\0\0")
    test_zrle("xyz\0\0", "xyz\0\1")
    test_zrle("xyz\0\0\0", "xyz\0\2")
end

function rle(in::IO, out::IO)
    eof(in) && return
    value = read(in, UInt8)
    count = UInt64(0)
    while !eof(in)
        value′ = read(in, UInt8)
        if value′ == value
            count += 1
        else
            write(out, value)
            BSDiff.write_leb128(out, count)
            value = value′
            count = UInt64(0)
        end
    end
    write(out, value)
    BSDiff.write_leb128(out, count)
    return out
end

rle(data::AbstractVector{UInt8}) =
    take!(rle(IOBuffer(data), IOBuffer()))

@testset "BSDiff" begin
    @testset "API coverage" begin
        # create new, old and reference patch files
        dir = mktempdir()
        old_file = joinpath(dir, "old")
        new_file = joinpath(dir, "new")
        suffix_file = joinpath(dir, "suffixes")
        write(old_file, "Goodbye, world.")
        write(new_file, "Hello, world!")
        # check API passing only two paths
        @testset "2-arg API" begin
            patch_file = bsdiff(old_file, new_file)
            new_file′ = bspatch(old_file, patch_file)
            @test read(new_file′, String) == "Hello, world!"
        end
        # check API passing all three paths
        @testset "3-arg API" begin
            patch_file = joinpath(dir, "patch")
            new_file′ = joinpath(dir, "new′")
            bsdiff(old_file, new_file, patch_file)
            bspatch(old_file, new_file′, patch_file)
            @test read(new_file′, String) == "Hello, world!"
        end
        @testset "bsindex API" begin
            bsindex(old_file, suffix_file)
            patch_file = bsdiff((old_file, suffix_file), new_file)
            new_file′ = bspatch(old_file, patch_file)
            @test read(new_file′, String) == "Hello, world!"
            # test that tempfile API makes the same file
            suffix_file′ = bsindex(old_file)
            @test read(suffix_file) == read(suffix_file′)
        end
        rm(dir, recursive=true, force=true)
    end
    @testset "registry data" begin
        registry_data = joinpath(test_data, "registry")
        old = joinpath(registry_data, "before.tar")
        new = joinpath(registry_data, "after.tar")
        ref = joinpath(registry_data, "reference.diff")
        old_data = read(old)
        new_data = read(new)
        @testset "low-level API" begin
            # test that diff is identical to reference diff
            diff = sprint() do io
                BSDiff.write_diff(io, old_data, new_data)
            end |> codeunits
            @test read(ref) == diff
            # test that applying reference patch to old produces new
            new_data′ = open(ref) do patch
                sprint() do new
                    BSDiff.apply_patch(old_data, patch, new, length(new_data))
                end |> codeunits
            end
            @test new_data == new_data′
        end
        if !Sys.iswindows() # bsdiff_jll doesn't compile on Windows
            @testset "high-level API" begin
                # test that bspatch command accepts patches we generate
                patch = bsdiff(old, new)
                new′ = tempname()
                bsdiff_jll.bspatch() do bspatch
                    run(`$bspatch $old $new′ $patch`)
                end
                @test new_data == read(new′)
                rm(new′)
                # test that we accept patches generated by bsdiff command
                patch = tempname()
                bsdiff_jll.bsdiff() do bsdiff
                    run(`$bsdiff $old $new $patch`)
                end
                new′ = bspatch(old, patch)
                @test new_data == read(new′)
            end
        end
        @testset "zero RLE patch" begin
            patch_file, io = mktemp()
            io = BSDiff.ZrleIO(io)
            BSDiff.write_diff(io, old_data, new_data)
            close(io)
            @test filesize(patch_file) == 89178
            @test read(ref) == open(patch_file) do io
                read(BSDiff.ZrleIO(io))
            end
        end
        @testset "timing" begin
            index = @time BSDiff.generate_index(old_data)
            @time BSDiff.write_diff(devnull, old_data, new_data, index)
            @time BSDiff.write_diff(devnull, old_data, new_data, index)
            @time BSDiff.write_diff(devnull, old_data, new_data, index)
        end
        @testset "zrle + timing" begin
            old_zrle = codeunits(zrle(String(copy(old_data))))
            new_zrle = codeunits(zrle(String(copy(new_data))))
            index = @time BSDiff.generate_index(old_zrle)
            @time BSDiff.write_diff(devnull, old_zrle, new_zrle, index)
            @time BSDiff.write_diff(devnull, old_zrle, new_zrle, index)
            @time BSDiff.write_diff(devnull, old_zrle, new_zrle, index)
        end
    end
end
